{"pdfpcFormat":2,"disableMarkdown":false,"noteFontSize":20,"pages":[{"idx":0,"label":"1","overlay":0,"note":"This presentation covers our implementation of the Nebula challenge. We have designed a simple NOC that is able to be reconfigured from 4 to 64 routers, in a 2D mesh configuration."},{"idx":1,"label":"2","overlay":0,"note":"The goal of this project was to design this NOC. The NOC uses a distributed network of routers, with each router connected to a single GPU.\n\nThe routers are arranged in a 2D mesh configuration, being able to host up to 64 GPUs easily. Further than 64, we had the idea of implementing clustered processing, but did not have time to implement it.\n\nWe used the AXI4 and CHI protocols for various parts of the router, and coded the majority of this project in SystemVerilog. For displaying and a little testing, we used Python for our web dashboard.\n\nOur process aimed to have distributed processing, along with simplistic routing to maximize processing. We have a 5 stage pipeline that we'll get to in a second, as well as a simple dashboard to watch the performance."},{"idx":2,"label":"3","overlay":0,"note":"To start with our top level system architecture, we'll head back to the router. \n\nWe instantiate the required number of routers using nebula_mesh_top, where each router is instantiated and connected to it's North, South, East and West neighbours. \n\nEach node consists of a GPU, the network interface controller, the memory controller and the router. Only the routers talk to each other on the mesh, ensuring that information gets passed along easily."},{"idx":3,"label":"4","overlay":0,"note":"Coming to the router and their nodes, here's a simple sample from our web dashboard of an 8x8 mesh. Each link carries the flit data, control signals (as a part of the flit header) and credit information (to help with routing decisions)."},{"idx":4,"label":"5","overlay":0,"note":"We have a 5 stage pipeline for the router. We begin with the buffer write, which checks the flit header and \n\n\n\nXY Routing: Dimension-ordered, deadlock-free. Adaptive Routing: Congestion-aware, selects least congested path. Implementation: Combinational logic compares router/destination coordinates, uses buffer utilization and credit counts. Programmable thresholds for adaptive switching. Technical details: Route Computation (lines 260-380), VC Allocation (630-690), Switch Allocation (460-570) in nebula_router.sv."},{"idx":5,"label":"6","overlay":0,"note":"Flit: 256 bits, defined in nebula_pkg.sv. Header fields: Type (HEAD/BODY/TAIL/SINGLE), Source/Dest coordinates, VC ID, Sequence number, Packet ID, QoS, CRC. Payload: 208 bits. Supports multi-flit and single-flit packets. Enables protocol support and error detection."},{"idx":6,"label":"7","overlay":0,"note":"AXI-NoC Bridge: Burst decomposition, address mapping, 64-entry reorder buffer, packet assembly/disassembly, error detection, latency monitoring. CHI-NoC Bridge: CHI message classification, VC mapping, directory-based MOESI coherency, snoop response aggregation, timeout/error handling. Outstanding Transaction Management: Hardware table tracks up to 64 operations (ID, address, burst, sequence, timeout)."},{"idx":7,"label":"8","overlay":0,"note":"Assembler: Converts protocol transactions to flit packets, header generation, payload segmentation, address-to-coordinate mapping. Disassembler: Reconstructs transactions from flits, CRC verification, sequence management, handles out-of-order/multi-path delivery. Ensures data integrity and protocol compliance."},{"idx":8,"label":"9","overlay":0,"note":"Credit Controller: Per-VC credit counters (max 16), increment on flit acceptance, decrement on allocation. Prevents buffer overflow and deadlock. credits_available signals for arbitration. Flow Control Protocol: Sender stalls if credits=0, lossless operation guaranteed."},{"idx":9,"label":"10","overlay":0,"note":"Top-Level Modules: nebula_system_top.sv (mesh instantiation, AXI4 interfaces, address mapping), nebula_mesh_top.sv (router grid, edge handling), nebula_top.sv (config registers, status, debug). Address Mapping: 64-bit global address space, static/dynamic schemes, hardware decoder for coordinate extraction. Collective Operations: Broadcast/multicast, hardware barriers, reduction support."},{"idx":10,"label":"11","overlay":0,"note":"Verification and Testing: RTL testbenches (unit, integration, system-level), Python tools (traffic generator, VCD parser). Metrics: Latency, throughput, congestion, error rates, performance counters. Ensures functional correctness, performance, and error recovery."},{"idx":11,"label":"12","overlay":0,"note":"Web Dashboard: Backend (Flask + Socket.IO), Frontend (JS + Vite + Tailwind). Features: Real-time mesh visualization, animated packet flows, congestion heatmap, performance metric graphing, VCD trace replay, simulation control, traffic pattern selection. Integration: Runs Verilog simulations, parses VCD, updates UI via WebSocket, API endpoints for mesh, performance, simulation control."},{"idx":12,"label":"13","overlay":0,"note":"Performance Monitoring: Router-level counters (packets per direction, buffer utilization, VC stats, congestion, temperature). System-level metrics (total packets, average latency, throughput, error tracking, historical trending). Visualization: Time-series graphs, mesh overlays, VCD replay for cycle-accurate analysis."},{"idx":13,"label":"14","overlay":0,"note":"Technical Challenges: Scalability (mesh generation, address mapping), Coherency (CHI edge cases, directory state), Adaptive Routing (congestion metrics, deadlock avoidance), Verification (multi-level coverage, error injection), Integration (protocol bridge correctness, counter aggregation), Visualization (real-time updates, VCD parsing, UI responsiveness)."},{"idx":14,"label":"15","overlay":0,"note":"Current Status: Completed (mesh topology, router pipeline, protocol bridges, AXI4/CHI support, assembler/disassembler, Python tools, dashboard, verification, monitoring). In Progress: Advanced adaptive routing, QoS, hierarchical clustering, enhanced CHI, dashboard analytics. Planned: FPGA prototyping, deep learning benchmarks, fault tolerance, dynamic reconfiguration."},{"idx":15,"label":"16","overlay":0,"note":"References: SystemVerilog RTL (code/rtl/), Python tools (code/python/), Testbenches (code/tb/), Documentation (docs/final_report.tex, docs/abstract.tex), Dashboard (web_dashboard/)."},{"idx":16,"label":"17","overlay":0,"note":"Q&A: Invite questions on technical architecture, implementation, verification, and future work."},{"idx":17,"label":"18","overlay":0,"note":"Nebula NoC is composed of modular, parameterized SystemVerilog RTL blocks. Each module is designed for scalability, protocol flexibility, and high throughput. This section details design decisions, code structure, and unique features of each RTL module."},{"idx":18,"label":"19","overlay":0,"note":"nebula_top.sv: System Integration (1/2) Design: Parameterized mesh size, protocol enable/disable, config bus widths. Unified config/status interface for software control. Modular instantiation of routers, bridges, monitoring logic. Key code: Parameter/function definitions, synchronous logic for control/status."},{"idx":19,"label":"20","overlay":0,"note":"nebula_top.sv: System Integration (2/2) Features: System-wide error aggregation, debug trace export, performance counters, status registers, scalable generate blocks. Key code: Generate loops for node instantiation, status aggregation logic."},{"idx":20,"label":"21","overlay":0,"note":"nebula_system_top.sv: System-Level Integration (1/2) Design: Centralizes mesh, memory, protocol bridge instantiation. Implements global address decoding/mapping. Coordinates system resets/status propagation. Key code: Mesh instantiation, address mapping logic."},{"idx":21,"label":"22","overlay":0,"note":"nebula_system_top.sv: System-Level Integration (2/2) Features: Flexible address mapping for heterogeneous memory, system-level reset/error handling, simulation/testbench hooks. Key code: Synchronous reset/control logic, error status propagation."},{"idx":22,"label":"23","overlay":0,"note":"nebula_mesh_top.sv: Mesh Topology (1/2) Design: 2D grid instantiation using nested generate loops, edge node handling, parameterized mesh width/height. Key code: Generate loops for X/Y, conditional logic for edge connections."},{"idx":23,"label":"24","overlay":0,"note":"nebula_mesh_top.sv: Mesh Topology (2/2) Features: Automated port wiring, edge detection logic, mesh reconfiguration for fault tolerance. Key code: Port connection logic, tie-off/wrap-around for edge cases."},{"idx":24,"label":"25","overlay":0,"note":"nebula_router.sv: Router Pipeline (1/2) Design: Five-stage pipeline, VC allocation, credit-based flow control, adaptive/deterministic routing. Key code: Synchronous logic for pipeline stages, combinational logic for route/switch allocation."},{"idx":25,"label":"26","overlay":0,"note":"nebula_router.sv: Router Pipeline (2/2) Features: Per-port/VC performance counters, error detection, round-robin arbitration. Key code: Performance counter increment, error flag, arbitration logic."},{"idx":26,"label":"27","overlay":0,"note":"nebula_axi_if.sv: AXI4 Interface (1/2) Design: Parameterized AXI widths, FIFO-based buffering, clock domain crossing. Key code: AXI signal assignments, FIFO push/pop, synchronizers."},{"idx":27,"label":"28","overlay":0,"note":"nebula_axi_if.sv: AXI4 Interface (2/2) Features: AXI burst handling, response reordering, backpressure propagation, error injection. Key code: Burst-to-packet conversion, response assembly, error logic."},{"idx":28,"label":"29","overlay":0,"note":"nebula_axi_noc_bridge.sv: AXI4-NoC Bridge (1/2) Design: Decomposes AXI bursts to NoC packets, reorder buffer for out-of-order responses, tracks outstanding transactions. Key code: AXI to NoC packet conversion, reorder buffer management."},{"idx":29,"label":"30","overlay":0,"note":"nebula_axi_noc_bridge.sv: AXI4-NoC Bridge (2/2) Features: Out-of-order response assembly, error detection/reporting, latency monitoring. Key code: Response assembly, error/latency logic."},{"idx":30,"label":"31","overlay":0,"note":"nebula_chi_interface.sv: CHI Protocol (1/2) Design: Implements CHI request/response/data channels, protocol sequencing state machine, snoop/directory support. Key code: CHI state machine, request/response logic."},{"idx":31,"label":"32","overlay":0,"note":"nebula_chi_interface.sv: CHI Protocol (2/2) Features: FIFO buffering for CHI channels, protocol error detection/recovery, directory/snoop integration. Key code: Buffer management, error handling."},{"idx":32,"label":"33","overlay":0,"note":"nebula_chi_noc_bridge.sv: CHI-NoC Bridge (1/2) Design: Maps CHI message types to NoC VCs, handles coherency/snoop/directory transitions, aggregates snoop responses, manages timeouts. Key code: CHI-to-NoC VC mapping, snoop aggregation, timeout logic."},{"idx":33,"label":"34","overlay":0,"note":"nebula_chi_noc_bridge.sv: CHI-NoC Bridge (2/2) Features: Timeout detection for snoop responses, priority mapping for CHI traffic, error handling for protocol mismatches. Key code: Timeout detection, priority encoding."},{"idx":34,"label":"35","overlay":0,"note":"nebula_chi_directory.sv: Directory Controller (1/2) Design: MOESI directory for cache coherency, handles snoop requests/state transitions, manages race conditions/corner cases. Key code: Directory state machine, snoop request/response logic."},{"idx":35,"label":"36","overlay":0,"note":"nebula_chi_directory.sv: Directory Controller (2/2) Features: MOESI state machine per cache line, snoop response aggregation/forwarding, error detection for invalid transitions. Key code: State transition, snoop aggregation."},{"idx":36,"label":"37","overlay":0,"note":"nebula_niu_axi.sv: AXI NIU (1/2) Design: Buffers/arbitrates between protocol/NoC domains, handles packetization/depacketization, manages local error/status. Key code: Buffering/arbitration, packetization logic."},{"idx":37,"label":"38","overlay":0,"note":"nebula_niu_axi.sv: AXI NIU (2/2) Features: Local error detection/reporting, arbitration between protocol sources, parameterized AXI widths."},{"idx":38,"label":"39","overlay":0,"note":"nebula_packet_assembler.sv: Packet Assembly (1/2) Design: Converts protocol transactions to NoC flit packets, segments payloads, generates headers with CRC/sequence. Key code: Header construction, payload segmentation, CRC."},{"idx":39,"label":"40","overlay":0,"note":"nebula_packet_assembler.sv: Packet Assembly (2/2) Features: Address-to-coordinate mapping, CRC generation, supports single/multi-flit packets."},{"idx":40,"label":"41","overlay":0,"note":"nebula_packet_disassembler.sv: Packet Disassembly (1/2) Design: Reconstructs protocol transactions from flits, verifies CRC/sequence, handles out-of-order/multi-path delivery. Key code: Reassembly logic, CRC/error handling."},{"idx":41,"label":"42","overlay":0,"note":"nebula_packet_disassembler.sv: Packet Disassembly (2/2) Features: Out-of-order reassembly, error flagging for CRC mismatches, sequence tracking."},{"idx":42,"label":"43","overlay":0,"note":"nebula_pkg.sv: Global Package (1/2) Design: Centralizes parameter/type/enum definitions, ensures consistency, provides utility functions. Key code: Parameter/type definitions, utility functions (CRC, coordinate mapping)."},{"idx":43,"label":"44","overlay":0,"note":"nebula_pkg.sv: Global Package (2/2) Features: Parameterized mesh/flit widths, strong type safety, utility functions for address/coordinate conversion."},{"idx":44,"label":"45","overlay":0,"note":"nebula_top_simple.sv: Minimal Top (1/2) Design: Minimal mesh/protocol integration for bring-up, used for unit/smoke tests. Key code: Minimal mesh instantiation, AXI interface, basic config/status."},{"idx":45,"label":"46","overlay":0,"note":"nebula_top_simple.sv: Minimal Top (2/2) Features: Fast simulation for connectivity checks, easy extension for new protocol bridges."},{"idx":46,"label":"47","overlay":0,"note":"common/: Reusable Modules (1/2) Design: Core NoC utilities (CRC, FIFO, credit flow, arbitration), parameterized for width/depth/protocol. Key code: CRC, FIFO, credit flow, round-robin arbiter."},{"idx":47,"label":"48","overlay":0,"note":"common/: Reusable Modules (2/2) Features: Round-robin arbitration, parameterized FIFO, modular/reusable code for NoC blocks. Key code: Generic FIFO logic, arbiter grant/request handling."}]}